#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

layout(local_size_x = 1) in;

struct Result{
    int hit;
    int customIdx;
    int instanceIdx;
    //dont use vec3
    float hitX;
    float hitY;
    float hitZ;
};

layout(binding = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1) buffer tensor { Result result[]; };

vec3 dir[6] = vec3[](
    vec3(0.0,0.0,1.0),
    vec3(0.0,0.0,-1.0),
    vec3(-1.0,0.0,0.0),
    vec3(1.0,0.0,0.0),
    vec3(0.0,1.0,0.0),
    vec3(0.0,-1.0,0.0)
);

void main() {
    uint idx = gl_GlobalInvocationID.x;
    vec3 start = vec3(0.0,0.0,0.0);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(
        rayQuery, tlas,
        gl_RayFlagsTerminateOnFirstHitEXT,
        0xFF, start, 0.01, dir[idx], 4.0);
    rayQueryProceedEXT(rayQuery);

    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        result[idx].hit = 1;
        result[idx].customIdx = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
        result[idx].instanceIdx = rayQueryGetIntersectionInstanceIdEXT(rayQuery, true);

        float t = rayQueryGetIntersectionTEXT(rayQuery, true);
        vec3 pos = dir[idx] * t;

        result[idx].hitX = pos.x;
        result[idx].hitY = pos.y;
        result[idx].hitZ = pos.z;
    }
    else {
        result[idx].hit = 0;
        result[idx].customIdx = 0;
        result[idx].instanceIdx = 0;
        result[idx].hitX = 0.0;
        result[idx].hitY = 0.0;
        result[idx].hitZ = 0.0;
    }
}
